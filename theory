# pillow and opencv image & video processing library
# pypdf2, smtplib library
# request module-browser without actually using browser, hashlib module
# tweepy lib for accessing twitter api
# twilio lib for sms, voice
# beautifulsoup lib, scrapy framework for web scraping
# requests lib
# pythonanywhere.com to host files-web app/web server
 machine learning- numpy lib, pandas data analysis lib,sciki-learn lib create model
 machine learning-matplot lib visualize data,seaborn lib on top of matplot,bokeh lib interactive visualization
 machine learning-kaggle.com ml community
django rest framework,docker,circleci,postgress
    tdd- increase test coverage, ensure tests work, encourages quality code
        1.setup-create sample database objects
        2.execution-call the code
        3.assertions-confirm expected output

    circleci-to automatically run linting & unit test via script-notify via email if build is broken,
    identify issues earl
    docker-isolate project depedencies,lightweight virtual machine,single image,consistent dev enironment
    deploy to cloud platform aws
    django rest framework-bultin authentication,viewsets(to create structure of our api and provide all of the 
    necessary endpoints for managing objects),serializers(to provide validation on all requests to our api and to
    help convert json objects to django database model),browsable web api(to test endpoints in the browser)

package-module-containing other modules
package-directories-__path__
module-file'
sys.path-package root-package init file


DJANGO
__init__.py- this is a blank python script that due to its special name python know that this directory
can be treated as a package
admin.py- you can register your models here which django will then use them with django admin interface
apps.py- here you can place application specific configurations
models.py- here you store the applications data models
tests.py- here you can score test functions to test your code
views.py- this is where you have functions that handle requests and return responses
migrations folder- this directory stores database specific information as it relates to the models
wsgi.py file- is for the server format WSGI, which Django supports natively. We can customize that for other server formats.
settings.py-Everything inside your Django project like databases, backend engines, middlewares, installed applications, main URL configurations, static file addresses, templating engines, allowed hosts
and servers and security key stores in this file as a list or dictionary.
render function-Render function is a shortcut function which lets the developer to easily pass the
data dictionary with the template.This function then combines the template with data dictionary via 
templating engine. Finally, this render() returns an HttpResponse with the rendered text, which is
 the data returned by the models.-render(request, template_name, context=None, content_type=None, status=None, using=None)

So, when your Django server starts it executes settings.py file and then loads particular engines and databases so that when a request is given it can serve the same quickly.

Templates- contains the static parts of an html page(parts that are always the same)
settings.py editing dir key inside of template dictionary-os.path.direname(file) dynamically generates path
Templates tags- have their own special syntax- this syntax allows you to inject dynamic content that
you django apps views will produce, effecting the final html- {{}} syntax- render(request,html,context)
Django templates render information in a designer-friendly format to present to the user. Using the Django Template Language (DTL), a user can generate HTML dynamically. Django templates consist of simple text files that can create any text-based format such as XML, CSV, and HTML.
Template method-We simply created a context dictionary and passed it to the template. The context 
dictionary has a key DataFlair which contained a DataFlair class object. To note, we execute the method when passing the object in the context variable. It is not recommended to pass methods like that.
 The method execution takes place before rendering.Thus, we can call methods in the template.
 Stop method execution while rendering-DTL also checks for some variables in methods automatically. 
 The variable we want to put in our method is alters_data = True. If we keep that variable in our method, the template system won’t render it. Instead, it will treat the context variable as an invalid variable.
It is true that the template system shall not be given access to some methods. Methods that can change
 data in the database are one of them. To prevent the execution of the method, we can keep a lock on
  the method definition itself.
{% for %} in the template system-
forloop.counter: The forloop counter will return the integer. The number of times the loop has run is 
displayed in it. The forloop counter starts counting from 1.
forloop.counter0: It is the same variable as the forloop counter but the counting starts from 0.
forloop.revcounter: The forloop reverse counter returns an integer. The number of times the loop will
 run or the number of items remaining. Its numbering ends on 1.
forloop.revcounter0: It is the same variable as forloop reverse counter. The numbering ends on 0 rather than 1.
forloop.first: This is a special variable that returns True or False. This variable is true when the loop
 runs for the first time and false for all other times.
forloop.last: This variable is similar to forloop.first. the only difference is that it marks the end
 of the list. It returns true when the list has ended and false otherwise.

Models-settings.py edit engine parameter used for databases
an essential part of any website is the ability to accept information from a user and input it into a
database and retrieve information from a database and use it to generate contents for the user
field- primary key-serial, unique=true
A model consists of all the necessary fields and attributes of your stored data. 
They are a single, definitive source of information regarding your data.
python manage.py migrate-after setting the models migrate the database, django do the heavy lifting of
creating sql databases that correspond to the models we created
python manage.py makemigrations app1- then register the changes to your app
admin.py- from django contrib import admin from app.models model1, admin.site.register(model1)
ModelClass-The model class is a pre-defined class of Django framework and every class which is a model 
must derive from the same.The model class has lots of benefits like you can define the field with specific attributes as you would do in SQL, but now the same can be achieved in Python.
Django Model class is parsed by the Django ORM or backend engine and you won’t need to do anything
 related to the database, like creating tables and defining fields afterward mapping the fields with
  the attribute of the class.

django operates on model-template-views
1. in the views.py we import any models that we will need to use
2. use the view to query the model for data that we will need
3. pass results from the model to the template
4. edit the template so that it is ready to accept and display the data from the model
5. map a url to the view

    Models. Describes the database schema and data structure
    Views. Controls what a user sees. The view retrieves data from appropriate models, executes any calculations made, and passes it on to the template
    Templates. Controls how the user sees the pages. It describes how the data received from the views need to be altered or formatted to display on the page
    Controller. Made up of the Django framework and URL parsing


Forms- quickly generates html form widgets, validate data and process it into a python data
structure, create form versions of our models quickly update models from Forms
there are several ways you can inject the form using template tagging. you can just pass in the key
from the context dictionary {{form}} {% csrf_token %}
csrf- cross site request forgery token secures the http post action that is initiated on the 
subsequent submission of a form

Modelform- grab input from the user and save it to a model- use forms.modelform in forms.py file
this helper class allows us to create a form from a pre-existing model, then we add an inline
class called meta. meta class provides information connecting the model to the form
class meta: modelname, fields-- __all__, exclude[field1,field2], (field1,field2)


URL.py-The URLs-config file in Django contains a list of URLs and mappings created to view those
 URLs' functions. The URLs can map to view functions, class-based views, and the URLs-config 
 of other applications.
templates url.py relative path- <a href ="{% url 'basicapp:thankyou' %}">
templates filters- some information from your model you wished to use across various webpages,
you wanted to make a slight edit to information before injecting it-{{value | filter:"parameter"}}
detailview update url.py- url(r'^update/?P<pk>\d+)/$', views.asview(),name=detail)
Reverse URL-Reverse URL resolution is the method of obtaining urls in their final forms. The URLs
 can be embedded in generated webpages. Like in the navigation bar, there are various scenarios.
  Django provides various methods to achieve this which otherwise could have been hardcoded.

Hardcoding these URLs is a time-consuming and error-prone task. Therefore, these ways are used instead of getting Url’s final form. The reverse resolution of URL is commonly achieved:

    In templates, by using url template tag.
    In Python code/view function, by using the reverse().
    In some high-level model class, by using get_absolute_url() method.

project vs app
The project covers the entire application, while an app is a module or application within the 
project that deals with one dedicated requirement. So, a project consists of several apps,
 while an app features in multiple projects.

Request/Response cycle
Starting the process off, the Django server receives a request. The server then looks for a 
matching URL in the URL patterns defined for the project. If the server can’t find a matching 
URL, it produces a 404-status code. If the URL matches, it executes the corresponding code in the view file 
associated with the URL and sends a response.

Signals-Signals are pieces of code containing information about what is currently going on. 
A dispatcher is used to both send and listen for signals.

Django rest framework-The Django Rest Framework (DRF) is a framework that helps you quickly 
create RESTful APIs. They are ideal for web applications due to low bandwidth utilization

Middleware in django
Middleware in the Django framework is the component that operates on request and transfers it to the 
view and before passing it to the template engine, it starts operating on a response.
You use middleware for four different functions:
Content Gzipping, Cross-site request forgery protection, Session management, Use authentication

RAW sql queries in django-
To begin, make sure that the DEBUG setting is set to True. If the setting is squared away, 
then type the following commands:
1) from Django.db import connection
2) connection.queries

Caching-Django supports these caching strategies:
Database caching,In-memory caching,File System Caching,Memcached 

QuerySet-QuerySet is a collection of SQL queries. The command print(b.query) shows you the SQL query
created from the Django filter call.

django.test.Client-The Client class acts like a dummy web browser, enabling users to test views and 
interact with Django-powered applications programmatically. This is especially useful when performing 
integration testing.


Django ORM-This ORM enables a developer to interact with a database in a pythonic way.
Django ORM is the abstraction between models (web application data-structure) and the database where 
the data is stored. It makes possible to retrieve, save, delete and perform other operations over the
 database without ever writing any SQL code. It also covers many loopholes and takes all the field 
 attributes and gives you more control over your code in Python rather than any database language.

USER authentication-Django’s User authentication not only authenticates (verifying the user identity) 
 the user but also authorizes him (determines what permissions the user have).
The system consists and operates on these objects:
  users, Permissions,Groups, Password Hashing System, Forms Validation, A pluggable backend system

Context variable lookup-Context variables are variables passed in templates. The DTL
 (Django Templating Language) replaces these variables. A context dictionary is used to perform the
  replacement. We pass the context dictionary alongside the render() alongside template information.
DTL has its own way of filling these variables and it’s in order. The template system can handle 
complex Python data structures as variables. The context variable lookups come in the role when the
 data is a dictionary, class object, etc.
 The context lookup will fill the value in this order.
Dictionary Values: The template system will look for dictionaries matching the variable name. 
It matches the key name with the name after the dot(.) operator.
Class Object Attribute values: If it didn’t find any dictionaries it will look for a class object. 
First lookups are done for attributes.
Class Object Methods: It looks for a particular attribute of that name. If the attribute is not 
found then it looks for methods.
List-Index lookup: At last, it will look for any lists with corresponding names. If it didn’t 
find any lists then it considers variable as an Invalid Variable.

Invalid Variable-There are various instances where a variable might not exist in context variables.
 In case DTL cannot find the variable in context, it considers that variable as an invalid variable.
The DTL handles the value for invalid variables. The DTL System will insert the value from a setting 
in these cases. The setting is an attribute of the engine named as string_if_invalid. By default, 
it’s an empty string. That empty string fills in the value in HTML render.

USER object-
User objects are our standard objects which have attributes like username, password, e-mail and 
name fields. The user objects have a set of fields that define the permissions for that user.
All users are not allowed to do everything and that’s where Django’s permission system comes in. 
Its an integrated part of Django admin.
There are 3 flags which determine the user activity, they are:
Active Flag: The active flag sets whether the user is active or not. this flag shall be on if the user
 wants to login otherwise system won’t log in the user. Even if the credentials entered by the user 
 are correct this flag still needs to be active.
Staff Flag: This flag differentiates between staff members and public users. It checks whether the user
 can access the admin-site. If he/she is not a staff, the response by the server is an error. Often a normal redirect is used in these case scenarios.
Superuser Flag: The superuser is the ultimate user of the admin site. It can Create, Update, Delete
 any object. If this flag is on then all regular permissions are available for this user. It can
  perform any sort of operation that exists in Django-Admin.

OBJECT permission-
Each object which can be edited in the Django admin has three permissions. Create Permission allows the
 user to create the objects one time. An Edit Permission allows the user to update the created objects. 
 A Delete Permission allows the user to delete objects.These permissions have an impact on the database too.

CUSTOM validation rule-
Custom validation rules are the customized rules used for form validation. Suppose we have a feedback form.
 There are fields like messages, email, and subject. If we get message data of 1 or 2 words that are of 
 no use to us. To check the issue, we use custom validation rules.
We simply define a method in our forms.py by the name clean_message(). This is the Django way to do
 it. The method’s name for custom validation should start with a clean_fieldname(). Django form system automatically looks for this type of method.Thus, these are called custom validation rules in Django.
It is always important to return the cleaned data of the field in a custom validation method.
 If not done, the method will return none instead resulting in loss of data.

django.contrib.auth.app-
 The auth app is a built-in Django application. It provides the developer with an authorization system. The auth app handles both authentication and authorization of users.
The authentication system consists of:
Users, Permissions,  Groups, Password Hashing System,view functions and an interface,
Customizable and plugins for the backend system
django.contrib.auth.get_user_model()-
The user model is the base model. Developers need it customized for their application. It should also 
contain all the security features that Django offers. Usually, they only want the inherited class and add or remove the field option there.
Now, get_user_model() will let us reference to user model. This method allows developers to use the 
custom user model. It is changed in setting AUTH_USER_MODEL in settings.py. The get_user_model() 
allows the developer to implement the changes. It can reference the custom user model where needed
 while avoiding global implementation. Since Django’s user model is tightly bundled with admin
  and auth. It is beneficial to customize Django’s user model.
The get_user_model() comes in here and resolved that. The get_user_model() will return an active 
user or a custom user. In case none of the two are present, it will return the user object.

CACHED_property() decorator-The cached_property() decorator is a built-in decorator. This decorator 
comes under the django.utils.functional module. The decorator’s property is to take the method as an
 argument. The method’s result is cached by the decorator for that instance.
This is useful when a method is computationally expensive. Also, its generated value is valid for a
 while or for the session.We can use this decorator just before we define the computationally 
 expensive method. That method’s answer is cached for the instance.Replace the pass with functional
  code. Also, import the method from django.utils.functional. These modules are provided by Django 
  to handle tedious tasks.

Q.16 What is the concept of laziness? How Django implements laziness?
Ans. Laziness is a complement of caching. We use both the processes to improve the efficiency of the program.
We implement caching by storing the result of a computationally expensive result. But, we implement laziness by not computing it until it’s actually required. The concept of laziness is doing things when it’s necessary. This approach has its own benefits. The more expensive the computation, the more we avoid it. It does work when it becomes a necessity.
Django is quite lazy. The most used example of laziness is querysets. We have used querysets quite often. The queryset objects are passed around even before they have the value. This approach is where we pass objects. Defining methods before the definition of its data, we call it laziness. It makes very easy for us to interact with databases.
Python support and encourages laziness. That makes it up for its performance issues many times.
It’s a concept made by lazy people implemented in computers.

Q.17 Django provides various optimizations for static files. Explain one of those solutions.
Ans. Static files are one of the main contents consuming the bandwidth of the client. There are times when a low network speed results in a poor experience for the consumer. There are various solutions to deal with this in Django.
Django developers came up with a solution using the browser’s caching behavior. The ManifestStaticFilesStorage class is the implementation of the solution.
The ManifestStaticFilesStorage class uses the browser caching ability. Using this class will improve site performance at low network speeds. The class when serving the static file appends a content-dependent tag with the file. The tag lets the browser store the file for a longer time. Django changes tag only when there is some change in the file. Otherwise, the browser uses the stored file.
The ManifestStaticFilesStorage serves the files with the names added with the MD5 Hash. Django generates the Hash from the content of the files. For example:
The filename is DataFlairStyle.css. The file stored by ManifestStaticFilesStorage Class is DataFlairStyle.55e7cbb9ba48.css.
Django serves the custom file to the browsers. Then if the file content changes do the MD5 hash. Thus, the browser will know which file to download. Browsers mostly cache the static files. It’s easier to just change the name if anything is changed in the backend. The browser will download it again if the file name changes.
That’s how we can improve the static files serving.

Q.18 Explain the management commands of django.contrib.staticfiles app.
Ans. The staticfiles app comes with three useful management commands. The commands are:
    collectstatic
    findstatic
    runserver –nostatic
We can execute the collectstatic command like this:
python manage.py collectstatic
As its name suggests, this command will collect all the static files from the directories. Django scans the directories in the setting STATICFILES_DIRS. All the static files found are then collected in directory STATIC_ROOT.
python manage.py findstatic staticfile [staticfile]
This command will return the path of static files found. The arguments contain the file name. We can append the filename within the directory to make the search more efficient.
Django searches files in directories set in STATICFILES_DIRS setting.
python manage.py runserver
This command can be confusing. The runserver is not a staticfiles management command by default. If the django.contrib.staticfiles is installed in Django, the runserver command is overridden.
The runserver command gets various options like:
    –nostatic : Serve requests without loading static files.
    –insecure : This command will force the app to serve static files even if the debug command is off.
These are the 3 management commands which we get with staticfiles app in django

Q.19 What is Pagination?
Ans. Pagination is a concept where we separate or divide data into different pages. It’s divided into multiple pages. The pages are provided as per user-request.
In the context of web applications: Suppose you search for anything on Google. Though Google claims they have found thousands of results in the resulting page, they give you only 10-20 results. Then you press the next page and you get more results. That is pagination.
Showing user only limited data is good for both of them. The user can sort the results easily and smoothly reach the information he/she wants. The bandwidth cost is not much for some results. Since the transfer-data is small, it gives results on low network speeds.
Pagination is also good for the server. The server can simply store the data in queryset or database and wait for the client to request more. This reduces the template overhead which would have been to generate a response. Generating a response with 1000 data is much more expensive than 10-20 data.
Pagination can drastically improve performance if done the right way.

Q.20 How do we implement pagination in Django?
Ans. We implement pagination in Django with the help of django.core.paginator classes. These classes help us manage and use paginated data.
From the code above, we have a list named datalist. That list is then divided into 2 pages. We can think of pages as numbered elements or parts of the object. The division occurred when we pass the list in the class constructor. The second parameter specifies the number of objects in one page. The pagination can be directly implemented in views.
The first argument can be a list, tuple or a Queryset.
In lines 7 and 8, we used some built-in attributes of Paginator class. The count will give the number of objects. It is the total number of objects. The num_pages will provide the number of pages made.
In this image, we are accessing the page data. We can access the page data with pages.page_range. This function works the way as a range in for loop. We can use object_list to access the contents on the page. It gives the list of objects. It’s not necessary though that the data need to be a list.
There are more functions in pagination.

Q.21 Explain password management in Django? In what format, Django stores passwords?
Ans. Django has various built-in tools to manage and store passwords. The way Django store passwords are encryption through various levels. Django uses the PBKDF2(Password Based Derivation Function 2) which is an industry-standard. The function results are also iterated over. Our passwords are finally stored in a way like this:
<algorithm>$<iterations>$<salt>$<hash>
This is the format in which Django stores a password. We specify the algorithm used before the dollar $ sign. The second part contains the number of iterations. The number of iterations over the algorithm is generally more than a million times. A random salt is included after that. The hash of the resulting password is the last part of the string.
The default hash used by Django is SHA256. NIST recommends these standards. Django’s password system is customizable. We can give it the customized algorithms but, in most cases, it’s not preferred. Default implementations are what most websites ever need. The default security is already very high.

Q.22 How does Django handle weak passwords? How it implements password validation?
Ans. Password validation is another very useful feature in Django. People often resort to using weak passwords. To prevent them from doing so, Django provides a solution. Django’s password validation system is a part of django.contrib.auth application.
The Django has PASSWORD_VALIDATORS for this purpose. The password validators will check the passwords before saving it. The validators like it must contain 8 characters. They are the validators that check the data like validating all characters are not digits. There are even validators that check passwords among the very common ones. For example passwords like test123, hello123, etc raise validation error.
We can even write our custom password validators in the case. The custom validators can even combine the user-information and test password. They can tell whether passwords are a combination of user-information or not.
There are various ways. The main requirement by any validator is its description. The validator must provide a description to the user as to what is wrong with the password.
Django handles password validation by the AUTH_PASSWORD_VALIDATORS setting.
This is the default validators. You can add custom validators easily once adding them with a password_validation class.

Q.23 Explain some built-in validators in Django.
Ans. The validator in Django checks the value. When the input value doesn’t meet certain constraints, Django raises ValidationError. is_valid() method handles ValidationError. The method then returns the value as False. Thus, we can ascertain whether the Form is providing valid data or not.
There are various built-in validators. We can access them using django.core.validators module. This module has a collection of validators for different fields in Django.
Some of the common validators we use include:
1. EmailValidator: This validator is the default one checking emails in models. This validator checks whether the input email is valid or not. If the email is not valid, it returns so with a message.
An important attribute of email validation is whitelist. The whitelist attribute of EmailValidator class contains a list of domains. Django will accept these domains regardless if they follow the general email conventions. The default value of that list includes localhost.
2. URLValidator: The URLValidator ensures that the inserted value looks like a URL. Now, it has some set of regular expressions. If the string passes that it shall be a URL. It doesn’t dial the URL in the browser actually accessing the link. If the validator doesn’t return anything, we get an invalid code.
The scheme parameter is important here. You can specify the scheme of URLs like http, https, FTP, etc. The accepted URLs shall have these schemes or protocols. This is the default value in the scheme parameter.
3. MaxValueValidator: As the name suggests, the maximum value that a field accepts. It checks the value, not length.
4. MinLengthValidator: This validator will check the length of the input. It raises ValidationError if the error exceeds a certain length.
There are other validators too, as Django provides a lot. We can use various parameters according to use. Using Django validators is always better than using custom validators. They provide a standard validation and are well integrated with the rest of Django. Although, writing custom validators is as easy.

Q.24 What are the various steps involved in form validation in Django?
Ans. The form validation is a complex process comprising several steps. An end result is a form where all the data is either partially or fully clean. The form can also be completely wrong. Form validation is the process of validating data before performing any database operations.
The steps involved in form validation include:
The first method executed is to_python() method. It will convert the data into the appropriate Python type to perform validation.
The second method is validate() method. It handles field-specific validation.
The third method is run_validators() method. It calls all the field’s validators. The collective errors are then returned by this method.
These three methods are actually executed in order. The clean() method calls all three methods in the appropriate order. This is a form class method. It calls all three to_python(), validate() & run_validators() methods. The comprised results and validation errors are returned.
That’s how we get a cleaned form or validated form.

Q.25 What are some good practices when writing custom validators? How do we raise ValidationErrors as recommended by Django?
Ans. Raising errors in Django shows how well planned a web-developer can be. There are certain ways recommended by Django to raise ValidationErrors.
    The ValidationErrors shall be descriptive and easy to comprehend.
    The error code shall be a descriptive one.
    Django encourages the use of the params parameter when returning variables.
    The params argument shall contain mapped data. Dictionaries are used in these cases.
    We use the gettext function or (_(‘text’)) to enable translation.
We have implemented all the concepts while raising validation error. A well thought validation error helps you better control the flow.

Q.26 What is the code layout for creating custom templates and filters?
Ans. Custom template tags are often used by programmers if the Django has a built-in tag. The custom template system is often defined in a different application. They are then made available to other Django templates.
The code layout works like this.
1. Make a new app. Install that application in the Django project.
Code:
python manage.py startapp dataflair
2. Make a new directory templatetags at the same level as views.py, models.py, etc…
3. Inside the templatetags directory, make a new file called __init__.py
4. Then write your template tags or custom logic in a Python file. You can name it anything relevant to custom templates.
5. The custom templates can be used by other templates. We use {% load “module-name” %} to load the templates.
The load tag will load all the custom templates defined in the file customDataFlair.
{% load customDataFlair %}
The template tags from the module will work if this is imported. There can be multiple load statements in the same template.

Q.27 What is the use of {autoescape} tag in DTL?
Ans. HTML escaping is important and developers should keep that in mind while coding. The HTML escaping means escaping character like “, &, <, >. The browser engine can interpret these characters as HTML Mark-up. These can sometimes lead to glitches. Also, in the worst scenario, the user gets a broken site. To prevent that to happen, we use HTML escaping. The Django developers have come up with a solution.
The solution to perform HTML escaping built-in is achieved by autoescape tag in DTL. The tag will identify the problem characters and replace them with escape characters. For example: “ represents &quot;. Other characters too have their escape sequences.
The {% autoescape %} tag has one argument. The argument can be on or off. That indicated whether auto-escaping is on or off. The code resides between {% autoescape %} and {% endautoescape %} tags.
This code will automatically look for any escape characters in dataflair.value variable. Then it will replace the escape characters if found.
This function can help us achieve a valid and bugless HTML. Django encourages the use of autoescape character.

Q.28 What are formsets in Django?
Ans. Formsets provide a layer of abstraction to developers. They enable developers to work with multiple forms on the same page. The formsets follow the analogy of datagrid. Django provides various functions in the forms module for this purpose.
If we want the user to create several objects at once, we use formsets. Django provides a class formset_factory for this purpose.
We can make our form a formset as shown in the line 19.
Now, we have made DjangoObjects a formset of DataFlairForm form. The formset_factory is a class present to help us in doing so.
Now, we can make an instance of this variable. The instance of the article will provide us with a list of forms. The for loop can iterate over that list. We can get multiple forms on a single page using this. 

Q.29 What are signals in Django?
Ans. Signals are messages for applications. The signals are present to transmit the occurring of an event. They can notify other apps that a particular event has occurred. These are pretty useful when the applications exist which are interested in a mutual event.
There are events like saving data in the database like deleting something from the database. There are various backend actions that are performed.
Signals are core functionality and may not be used in every project. Still, it’s nice to have an application that can help us use it.
Django’s signal is especially good as it transmits objects between applications. The native implementation is very efficient. There are various signals provided by Django like:
django.db.models.signals.pre_save
django.db.models.signals.post_save
django.db.models.signals.pre_delete
django.db.models.signals.m2m_changed
django.core.signals.request_started
These are the common ones. There are others as well.

Q.30 How do you listen to signals in Django?
Ans. We use signals to transmit messages between applications. The messages will give notification of an event. The Signals package provides various functions to make signals.
There are also functions to receive or listen to signals.
To receive a signal we use Signal.connect() method in an app. The method has some important parameters.
The signal will call receiver function when connect() function gets a message. The message signifies the occurrence of event. Django handles the signaling and activating of all these things.
The connect() method takes 4 parameters:
    receiver
    sender
    weak
    dispatch_uid
The receiver refers to a call back function. Django calls the receiver function when it gets the signal.
The sender parameter takes a specific sender. A particular sender is set to receive signals from. The weak attribute takes two values, True or False. Django stores signals as weak references. Garbage collectors handle weak references. When the receiver function is local, it can be garbage collected. To prevent this, weak is set to false.
The last parameter is a unique id. We use it to distinguish between duplicate signal receivers.
Setting these parameters in a function will make the signal receiver. The receiver can then execute a function when an event occurs.
These also support backward compatibility. The utils module of Django is a very powerful set of tools.


PYTHON-

Object- a=3
1. Create an object to represent the value 3.
2. Create the variable a, if it does not yet exist.
3. Link the variable a to the new object 3.
Types Live with Objects, Not Variables
>>> L2 = L1[:] # Make a copy of L1 (or list(L1), copy.copy(L1), etc.)
import copy
X = copy.copy(Y) # Make top-level "shallow" copy of any object Y
X = copy.deepcopy(Y) # Make deep copy of any object Y: copy all nested parts
>>> L == M # Same values
True
>>> L is M # Same object
>>> X = 42
>>> Y = 42 # Should be two different objects
>>> X == Y
True
>>> X is Y # Same object anyhow: caching at work!
True
In this interaction, X and Y should be == (same value), but not is (same object) because
we ran two different literal expressions (42). Because small integers and strings are
cached and reused, though, is tells us they reference the same single object.
>>> import sys
>>> sys.getrefcount(1) # 647 pointers to this shared piece of memory
>>> 'spam'[1:3] # Slicing syntax
'pa'
>>> 'spam'[slice(1, 3)] # Slice objects with index syntax + object
'pa'
>>> ord('s')
115
>>> chr(115)
's'
Technically, both of these convert characters to and from their Unicode ordinals
>>> S = chr(ord(S) + 1)
>>> S
'6'
>>> B = '1101' # Convert binary digits to integer with ord
>>> I = 0
>>> while B != '':
... I = I * 2 + (ord(B[0]) - ord('0'))
... B = B[1:]
...
>>> I
13
>>> S = 'spammy'
>>> L = list(S)
>>> L
['s', 'p', 'a', 'm', 'm', 'y']
>>> S = ''.join(L)
>>> S
'spaxxy
>>> line = "i'mSPAMaSPAMlumberjack"
>>> line.split("SPAM")
["i'm", 'a', 'lumberjack']
print('{0}={1}'.format('spam', 42)) # Format method: in 3.0+ and 2.6+
print('{}={}'.format('spam', 42)) # With autonumbering: in 3.1+ and 2.7
['spam', 'eggs', 'SPAM!']
>>> L[0:2] = ['eat', 'more'] # Slice assignment: delete+insert
>>> L # Replaces items 0,1
['eat', 'more', 'SPAM!']
>>> L.extend([8, 9, 10]) # Insert all at end, named method
>>> L.append('please') # Append method call: add item at end
>>> L.sort(key=str.lower, reverse=True) # Change sort order
>>> sorted(L, key=str.lower, reverse=True) # Sorting built-in
>>> L.reverse() # In-place reversal method
>>> L
[4, 3, 2, 1]
>>> list(reversed(L)) # Reversal built-in with a result (iterator)


Iteration Protocol-
It’s really
based on two objects, used in two distinct steps by iteration tools:
• The iterable object you request iteration for, whose __iter__ is run by iter
• The iterator object returned by the iterable that actually produces values during
the iteration, whose __next__ is run by next and raises StopIteration when finished
producing results
The Python iteration protocol, used by for loops, comprehensions, maps, and more, and
supported by files, lists, dictionaries, Chapter 20’s generators, and more. Some objects are both
iteration context and iterable object, such as generator expressions and 3.X’s flavors of some tools
(such as map and zip). Some objects are both iterable and iterator, returning themselves for the iter()
call, which is then a no-op.
>>> L = [1, 2, 3]
>>> I = iter(L) # Obtain an iterator object from an iterable
>>> I.__next__() # Call iterator's next to advance to next item
 map is similar to a list comprehension but is more limited because it
requires a function instead of an arbitrary expression. It also returns an iterable object
itself in Python 3.X, so we must wrap it in a list call to force it to give us all its values
at once; more on this change later in this chapter. Because map, like the list comprehension, is related to both for loops and functions, 
. For example, sorted sorts items
in an iterable; zip combines items from iterables; enumerate pairs items in an iterable
with relative positions; filter selects items for which a function is true; and reduce
runs pairs of items in an iterable through a function. All of these accept iterables, and
zip, enumerate, and filter also return an iterable in Python 3.X, like map
>>> import functools, operator
>>> functools.reduce(operator.add, open('script2.py'))
 unlike map and others, sorted returns an actual list in Python 3.X
instead of an iterable.
>>> list(zip('abc', 'xyz')) 
[('a', 'x'), ('b', 'y'), ('c', 'z')]
map,zip,filter,range 
Like range, the map, zip, and filter built-ins also become iterables in 3.X to conserve
space, rather than producing a result list all at once in memory. All three not only
process iterables, as in 2.X, but also return iterable results in 3.X. Unlike range, though,
they are their own iterators—after you step through their results once, they are exhausted. In other words, you can’t have multiple iterators on their results that maintain
different positions in those results.
It’s important to see how the range object differs from the built-ins described in this
section—it supports len and indexing, it is not its own iterator (you make one with
iter when iterating manually), and it supports multiple iterators over its result that
remember their positions independently:
 zip, map, and filter do not support multiple active iterators on the
same result; because of this the iter call is optional for stepping through such objects’
dictionary
 the dictionary keys, values, and
items methods return iterable view objects that generate result items one at a time,
instead of producing result lists all at once in memory. 
View items maintain the same physical ordering as that of the dictionary and reflect changes
made to the underlying dictionary.  dictionaries still are iterables themselves, with an iterator that returns
successive keys. Thus, it’s not often necessary to call keys directly in this context:
convert
keys views first with a list call, or use the sorted call on either a keys view or the
dictionary itself
>>> for k in sorted(D): print(k, D[k], end=' ') # "Best practice" key sorting
User-defined functions can be turned into iterable generator functions, with
yield statements.
• List comprehensions morph into iterable generator expressions when coded in
parentheses.
User-defined classes are made iterable with __iter__ or __getitem__ operator overloading.
def
def is executable code, def creates an object and assigns it to a name, lambda creates an object but returns it as a result, return sends a result object back to the caller,yield sends a result object back to the caller, but remembers where it left off, global declares module-level variables that are to be assigned, nonlocal declares enclosing function variables that are to be assigned,  Arguments are passed by assignment (object reference),
Arguments are passed by position, unless you say otherwise, Arguments, return values, and variables are not declared

Scopes-
 If a variable is assigned inside a def, it is local to that function.
• If a variable is assigned in an enclosing def, it is nonlocal to nested functions.
• If a variable is assigned outside all defs, it is global to the entire file
Python’s name-resolution scheme is sometimes called the LEGB rule, after the scope
names:
• When you use an unqualified name inside a function, Python searches up to four
scopes—the local (L) scope, then the local scopes of any enclosing (E) defs and
lambdas, then the global (G) scope, and then the built-in (B) scope—and stops at
the first place the name is found. If the name is not found during this search, Python
reports an error.
• When you assign a name in a function (instead of just referring to it in an expression), Python always creates or changes the name in the local scope, unless it’s
declared to be global or nonlocal in that function.
• When you assign a name outside any function (i.e., at the top level of a module
file, or at the interactive prompt), the local scope is the same as the global scope—
the module’s namespace
 Global names are variables assigned at the top level of the enclosing module file.
 Global names must be declared only if they are assigned within a function.
• Global names may be referenced within a function without being declared
nonlocal
 nested functions can reference variables
in an enclosing function’s scope, even if that function has already returned. It turns out
that, in Python 3.X (though not in 2.X), we can also change such enclosing scope variables, as long as we declare them in nonlocal statements. With this statement, nested
defs can have both read and write access to names in enclosing functions. 
The nonlocal statement is similar in both form and role to global, covered earlier. Like
global, nonlocal declares that a name will be changed in an enclosing scope. Unlike
global, though, nonlocal applies to a name in an enclosing function’s scope, not the
global module scope outside all defs. Also unlike global, nonlocal names must already
exist in the enclosing function’s scope when declared—they can exist only in enclosing
functions and cannot be created by a first assignment in a nested def.
 Immutable arguments are effectively passed “by value.” Objects such as integers and strings are passed by object reference instead of by copying, but because
you can’t change immutable objects in place anyhow, the effect is much like making
a copy.
• Mutable arguments are effectively passed “by pointer.” Objects such as lists
and dictionaries are also passed by object reference, which is similar to the way C
passes arrays as pointers—mutable objects can be changed in place in the function,
much like C arrays.

generator functions and expressions
Generator functions (available since 2.3) are coded as normal def statements, but
use yield statements to return results one at a time, suspending and resuming their
state between each.
• Generator expressions (available since 2.4) are similar to the list comprehensions
of the prior section, but they return an object that produces results on demand
instead of building a result list.
. The state that
generator functions retain when they are suspended includes both their code location,
and their entire local scope. Hence, their local variables retain information between
results, and make it available when the functions are resumed.
The chief code difference between generator and normal functions is that a generator
yields a value, rather than returning one—the yield statement suspends the function
and sends a value back to the caller, but retains enough state to enable the function to
resume from where it left off. When resumed, the function continues execution immediately after
 the last yield run.
 The net effect is that generator functions, coded as def statements containing yield
statements, are automatically made to support the iteration object protocol and thus
may be used in any iteration context to produce results over time and on demand
met in Chapter 14—the generator function was compiled to return this automatically. The returned
generator object in turn has a __next__ method that starts the function or resumes it
from where it last yielded a value, and raises a StopIteration exception when the end
of the series of values is reached and the function returns
Notice that the top-level iter call of the iteration protocol isn’t required here because
generators are their own iterator, supporting just one active iteration scan. To put that
another way generators return themselves for iter, because they support next directly.
Generator functions
A function def statement that contains a yield statement is turned into a generator
function. When called, it returns a new generator object with automatic retention
of local scope and code position; an automatically created __iter__ method that
simply returns itself; and an automatically created __next__ method (next in 2.X)
that starts the function or resumes it where it last left off, and raises StopItera
tion when finished producing results.
Generator expressions
A comprehension expression enclosed in parentheses is known as a generator expression. When run, it returns a new generator object with the same automatically
created method interface and state retention as a generator function call’s results
—with an __iter__ method that simply returns itself; and a _next__ method
(next in 2.X) that starts the implied loop or resumes it where it last left off, and
raises StopIteration when finished producing results.
extended yield
> def both(N):
yield from range(N)
yield from (x ** 2 for x in range(N))
Python 3.3 introduces extended syntax for the yield statement that allows delegation
to a subgenerator with a from generator clause. In simple cases, it’s the equivalent to a
yielding for loop—
In more advanced roles, however, this extension allows subgenerators to receive sent
and thrown values directly from the calling scope, and return a final value to the outer
generator. The net effect is to allow such generators to be split into multiple subgenerators much as a single function can be split into multiple subfunctions

...

DOCKER
docker compose	up	starts	up	all	the	containers.
• docker compose	ps checks	the	status	of	the	containers	managed	by	docker compose.
• docker compose	logs outputs	colored	and	aggregated	logs	for	the	compose-managed
containers.
• docker compose	logs with	dash	f	option	outputs	appended	log	when	the	log	grows.
• docker compose	logs with	the	container	name	in	the	end	outputs	the	logs	of	a	specific
container.
• docker compose	stop stops	all	the	running	containers	without	removing	them.
• docker compose	rm removes	all	the	containers.
• docker compose	build rebuilds	all	the	images.
bridge-default ,none-isolated,host
dockermachine -multi host environment via vm
docker start relate to docker compose in docker swarm

GIT
new repo- git init,undoing staged changes-git reset head
restore your changes-git checkout head, switch branch-git checkout branchname
orign live git remote v
git pull-git fetch and git merge(three way merge,diff from origin and merge)
merge conflict resolve-git reset --hard head
replacing set of commits-git rebase
undo-soft(reference back to specified commit only),mixed(soft()+staging area back),hard(mixed+rolls working directory)
stash(dirty state of working directory,saves stack of unfinished changes apply later)-switch to branches but don't want commit half done work
git stash apply, git cherry-pick commit_id


DESIGN PATTERN-duck
INTERFACE quackable-quack()
xduck implement interface quackable
goose-honk(), adapter-gooseadapter implement quackable(goose, gooseadapter(goose),quack(goose.honk))
DECORATOR-quackcounter implement quackable(quackable, quack(),quackcounter(quackable))-new quackcounter(new xduck())
FACTORY-public abstract class AbstractDuckFactory {public abstract Quackable createMallardDuck()
  public class DuckFactory extends AbstractDuckFactory {
public Quackable createMallardDuck() {return new MallardDuck();}
public class CountingDuckFactory extends AbstractDuckFactory {public Quackable createMallardDuck() {
return new QuackCounter(new MallardDuck());}
AbstractDuckFactory duckFactory = new CountingDuckFactory();
Quackable mallardDuck = duckFactory.createMallardDuck();
manage,composite-public class Flock implements Quackable {
ArrayList quackers = new ArrayList();
public void add(Quackable quacker) {quackers.add(quacker);}
public void quack() {Iterator iterator = quackers.iterator()
  Flock flockOfDucks = new Flock();flockOfDucks.add(redheadDuck)
OBSERVER-individual duck behaviour
public interface QuackObservable {public void registerObserver(Observer observer);
public void notifyObservers();}
public interface Quackable extends QuackObservable {public void quack();}
public class Observable implements QuackObservable {ArrayList observers = new ArrayList();
QuackObservable duck;public Observable(QuackObservable duck) {this.duck = duck;}
public void registerObserver(Observer observer) {observers.add(observer);}
public void notifyObservers() {Iterator iterator = observers.iterator();
  public class MallardDuck implements Quackable {
Observable observable;public MallardDuck() {observable = new Observable(this);}
public void quack() {notifyObservers();}
public void registerObserver(Observer observer) {observable.registerObserver(observer);}
public void notifyObservers() {observable.notifyObservers();}
public interface Observer {public void update(QuackObservable duck);}
Quackologist quackologist = new Quackologist();
flockOfDucks.registerObserver(quackologist);

MVC pattern-
The Model consists of the data and business logic.
• The View is responsible for rendering the data in a way that is human readable on a
screen.
• The Controller is the brains behind the app and communicates with both the Model
and the View. The user interacts with the app via the Controller.
• When applying MVC to Android, the Android Activity ends up serving as both the
View and Controller, which is problematic for separation of concerns and unit
testing

MVP patern-
Unlike MVC wherein the main entry point is the Controller, in MVP the main entry
point is the View.
he Model is the data layer that handles business logic.
• The View displays the UI and informs the Presenter about user actions.
• The View extends Activity or Fragment.
• The Presenter tells the Model to update the data and tells the View to update the UI.
• The Presenter should not contain Android framework-specific classes.
• The Presenter and the View interact with each other through interfaces.

MVVM pattern-relate to MVP-seoeration of concerns
View-View displays the UI and informs the other layers about user actions.
 ViewModel exposes information to the View.
Views display the UI and inform about user actions.
The View holds a reference to your ViewModel. The ViewModel property is
defined as a lateinit var so that the compiler knows it won't be initialized until
after class initialization.
ViewModel-The ViewModel gets the information from your Data Model, applies the necessary
operations and exposes the relevant data to your Views.
It exposes backend events to the Views so they can react accordingly.
The ViewModel class is designed to store and manage UI-related data in a lifecycleaware way.
• The ViewModel class allows data to survive configuration changes, such as screen
rotations.
• LiveData is a data holder class, just like a List or a HashMap, that can be observed for
any changes within a given lifecycle.
It declares a property that will contain a LiveData list of items. The
LiveData class allows any View to observe for any changes on the list and update
the UI.
Model-The Model, also known as the DataModel, retrieves information from your backend
and makes it available to your ViewModels.
 Model retrieves information from your datasource and exposes it to the ViewModels

VIPER pattern
The View displays the User Interface.
• The Interactor performs actions related to the Entities.
• The Presenter acts as a command center to manage your Views, Interactors and
Routers.
• The Entity represents data in your app.
• The Router handles the navigation between your Views.
• VIPER is a great architecture pattern for projects that are expected to scale fast but
might be overkill for simple apps.

RXJAVA-
Everything is a sequence in RxJava, and the primary sequence type is Observable,create by .just()
• Observables start emitting when they are subscribed to.
• You must dispose of subscriptions when done with them, and you’ll often use a
CompositeDisposable to do so.
• Single, Completable and Maybe are specialized observable types that are handy
in certain situations.

• Subjects are Observables that are also observers.
• You can send events over subjects by using onNext, onError and onComplete.
• PublishSubject is used when you only want to receive events that occur after
you’ve subscribed.
• BehaviorSubject will relay the latest event that has occurred when you subscribe,
including an optional initial value.
• ReplaySubject will buffer a configurable number of events that get replayed to
new subscribers. You must watch out for buffering too much data in a replay
subject.
• AsyncSubject only sends subscribers the most recent next event upon a complete
event occurring.
• The RxRelay library can be used with relays in place of subjects, to prevent
accidental complete and error events to be sent.

APP PERFORMANCE-
jetpack benchmark lib @rule,tests in CI without Gradle, or locally if you're using a different build system
Benchmark outputs a JSON file with results and metadata from a test run. This JSON file is written to
external storage on the device. You must to pull the file from the device with each run.
strictmode-long running operations,traceview,gpu profiling,android profiler

